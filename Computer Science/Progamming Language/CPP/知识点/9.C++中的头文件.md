<font style="color:rgb(51, 51, 51);">C++ 语言支持</font>**<font style="color:rgb(51, 51, 51);">"分别编译"（separate compilation）</font>**<font style="color:rgb(51, 51, 51);">。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。</font>**<font style="color:rgb(51, 51, 51);">.cpp 文件里的东西都是相对独立的</font>**<font style="color:rgb(51, 51, 51);">，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）。</font>

<font style="color:rgb(51, 51, 51);">编译器在编译 b.cpp 的时候会生成一个</font>**<font style="color:rgb(51, 51, 51);">符号表（symbol table）</font>**<font style="color:rgb(51, 51, 51);">，</font><u><font style="color:rgb(51, 51, 51);">像 "void a()" 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。</font></u>

<font style="color:rgb(51, 51, 51);">所谓的头文件，其实它的内容跟 .cpp 文件中的内容是一样的，都是 C++ 的源代码。但头文件不用被编译。我们把所有的函数声明全部放进一个头文件中，当某一个 .cpp 源文件需要它们时，它们就可以通过一个宏命令 "#include" 包含进这个 .cpp 文件中，从而把它们的内容合并到 .cpp 文件中去。当 .cpp 文件被编译时，这些被包含进去的 .h 文件的作用便发挥了。</font>

# <font style="color:rgb(34, 34, 38);">头文件（.h）</font>
<u>写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体实现。</u>

在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句：

```cpp
#ifndef HELLO_H
#define HELLO_H
 
//Your codes
 
#endif
```

这样做是为了<u>防止重复编译，不这样做就有可能出错。</u>至于HELLO_H这个名字实际上是无所谓的，叫什么都行，只要符合规范就行。原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。

参考[4.预处理器](https://www.yuque.com/zhengedaidan-knmgi/ye9qnn/psbg6ggpnkwg901r)

# <font style="color:rgb(34, 34, 38);">9.2 源文件（.cpp）</font>
**<font style="color:rgb(77, 77, 77);">源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。</font>**<font style="color:rgb(77, 77, 77);">那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。</font>

# 9.3 <font style="color:rgb(51, 51, 51);">#include</font>
<font style="color:rgb(51, 51, 51);">#include 是一个来自 C 语言的</font>**<font style="color:rgb(51, 51, 51);">宏命令</font>**<font style="color:rgb(51, 51, 51);">，它在编译器进行编译之前，即在</font><u><font style="color:rgb(51, 51, 51);">预编译的时候就会起作用。</font></u><font style="color:rgb(51, 51, 51);">#include 的作用是把它后面所写的那个文件的内容，全部包含到当前的文件中。</font><u><font style="color:rgb(51, 51, 51);">其本身没有任何作用与副功能的，它的作用就是把每一个它出现的地方，替换成它后面所写的那个文件的内容。简单的</font></u>**<u><font style="color:rgb(51, 51, 51);">文本替换</font></u>**<font style="color:rgb(51, 51, 51);">，别无其他。</font>

# 9.4 头文件的内容
<font style="color:rgb(51, 51, 51);">头文件的作用是被其他 .cpp文件包含进去的，其本身并不参与编译，但是它的内容可以被多个.cpp 文件使用并编译。</font>

**<font style="color:rgb(51, 51, 51);">只能定义一次，</font>**<font style="color:rgb(51, 51, 51);">头文件中应该只放变量和函数的声明，而不能放它们的定义。因为一个头文件的内容实际上是会被引入到多个不同的 .cpp 文件中的，并且它们都会被编译。放声明当然没事，如果放了定义，那么也就相当于在多个文件中出现了对于一个符号（变量或函数）的定义，纵然这些定义都是相同的，但对于编译器来说，这样做不合法。</font>

**<font style="color:rgb(51, 51, 51);">.h头文件中，只能存在变量或者函数的声明，而不要放定义。</font>**<font style="color:rgb(51, 51, 51);">即，只能在头文件中写形如：extern int a; 和 void f(); 的句子。这些才是声明。如果写上 inta;或者 void f() {} 这样的句子，那么一旦这个头文件被两个或两个以上的 .cpp 文件包含的话，编译器会立马报错。</font>

**<font style="color:rgb(51, 51, 51);">extern特例：</font>**

+ <font style="color:rgb(51, 51, 51);">一，头文件中可以写 const 对象的定义。因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同时，因为这些 .cpp 文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些 .cpp 文件中的这个 const 对象的值是相同的，可谓一举两得。同理，static 对象的定义也可以放进头文件。</font>
+ <font style="color:rgb(51, 51, 51);">二，头文件中可以写内联函数（inline）的定义。因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办呢？这几乎没什么太好的解决办法，因此 C++ 规定，内联函数可以在程序中定义多次，只要内联函数在一个 .cpp 文件中只出现一次，并且在所有的 .cpp 文件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。</font>
+ <font style="color:rgb(51, 51, 51);">三，头文件中可以写类（class）的定义。因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。所以把类的定义放进头文件，在使用到这个类的 .cpp 文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。一般，我们的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中。这是可以的，也是很好的办法。不过，还有另一种办法。那就是直接把函数成员的实现代码也写进类定义里面。在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。</font>

  
  


